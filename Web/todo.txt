* make the circle large enough to hold the whole square (hypotneuse!)

* think about which samples should be taken when there are too many!
 * maybe prefer thicker over thinner
 * or take inside and outside and get rid of middle
 * solve it!

* better paint tools in creator?
 * copy/paste (for multi frames)
 * load image (for source or encoded panel)

* make a diff tool to combine multiple single frame images into a multi frame image
 * multiple encoded frames in one image (for sprite sheets and animation)
 * be able to animate the preview (result) for multi frame images
  * maybe only bilinear filter on x axis

* base image applied before the clicks
 * this makes it so image loading works, as well as undo

* find a better name than "rot shapes"

* doing a single click with the paintbrush doesn't make a dot

* how to handle when drawing in corners? the image should support that so maybe we need to make each channel additive instead of add up to 1.
 * or maybe we "denormalize" it somehow so that the distances are extended to a rectangle?

* how do we handle the center pixel? angle = ??!! atan2 failure i think.

* protect against letters in the input boxes somehow (makes NAN)
* make sure the AA pixel distance is protected against < 1 and letters (NANs)

* double check that we aren't ever reading out of bounds.  like esp in the results reading of the encoded image

* Only 256 distances. Skewed somehow by squared distance (good or bad??).
  * Bilinear filtering should help fake more distances maybe? Texture repeat mode should help negatives and wrap around
  * investigate

* how can you AA horizontally?

* test / talk about: rectangular shapes both in source and dest

* instead of only making boundary samples when making encoded image, maybe should try lerping between boundaries!

* try unsquared distance. compare / contrast

* encoding might want to write to multiple buckets? not sure... need to think about it

* organize code

=====
Later...
* a playground to investigate the properties of the image (scale, zoom, tint, anti aliasing, etc)
 * in webgl?
 * w/ animation
 * stroke and drop shadow

* a performance test playground vs a regular texture

* share pixel shader code to decode rot images from UV coordinates

* show shader code to decode rot images, based on options selected!

* a playground that lets you layer multiple tinted (and animated?) layers?

* see how this holds up to dxt compression (maybe jpg too?)

* sample library & research
 * text
 * asian text
 * google icons
 * animated icons
 * get pixel artists involved

* test in IE, Firefox, and on mac

* benchmark vs other methods (regular textures & distance textures)

=====FUTURE WORK=====

* other ways of converting images to the encoded image
   * like, instead of casting a ray, could do a cone and average distances found or something.
   * could use bressenham's algorithm if just casting a ray.

* look at being able to do AA in "squared distance space" somehow?

* could decrease # of color channels if you don't need all this info.
 * 2 color channels = out, in, out (1 spiral)
 * 1 color channel = in (could describe a convex shape)

* heuristic for which features to keep (middle, thickest, inside, outside, etc)

=====NOTES=====


? what should happen if result isn't square but source is.  Should it stretch?
 ! this is controlled by however the UV coordinates are set up.

? fill tool in encoder?
 ! there is no flood fill in javascript/html5 so would need to code it by hand.  image important should be good enough.

? we dont use the full range of the float (0-1) for each color channel, maybe we can improve that
