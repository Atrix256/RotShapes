<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>RotShape Creator</title>
<style type="text/css">
body { background-color:grey;}
canvas.html5 {border:1px solid white;}
div.panel {float:left; width:33%;}
</style>
<script>

var g_sourcePanel;
var g_encodedPanel;
var g_encoded2Panel;
var g_resultPanel;
var g_mouseDown = false;
var g_brushSize = 5;

var g_AAmount = 0.01;
var g_bilinearFilter = false;

var g_color = 1;

var g_clicks = new Array();

var g_redrawTimer = 0;

function onPageLoaded()
{
	g_sourcePanel = setupCanvas('Source');
	g_encodedPanel = setupCanvas('Encoded');
	g_encoded2Panel = setupCanvas('Encoded2');
	g_resultPanel = setupCanvas('Result');

	g_sourcePanel.elem.addEventListener('mousemove', function(evt) {OnMouseMove(evt);RedrawAll(false);}, false);
	g_sourcePanel.elem.addEventListener('mousedown', function(evt) {OnMouseDown(evt);RedrawAll(false);}, false);
	g_sourcePanel.elem.addEventListener('mouseup', function(evt) {OnMouseUp(evt);RedrawAll(false);}, false);
	g_sourcePanel.elem.addEventListener('mouseleave', function(evt) {OnMouseUp(evt);RedrawAll(false);}, false);
	RedrawAll(true);

	setInterval(function(){RedrawChecker();}, 100);
}

function setupCanvas(name)
{
  // Get a reference to the element.
  var elem = document.getElementById(name);

  // Always check for properties and methods, to make sure your code doesn't break 
  // in other browsers.
  if (elem)
  {
    if(elem.getContext)
    {
      // Get the 2d context.
      // Remember: you can only initialize one context per element.
      var context = elem.getContext('2d');

      if (context)
      {
      	return {"elem":elem, "context":context, "clear":function(){ClearImageBuffer(context,elem.width,elem.height)}, "fill":function(color){FillImageBuffer(context, color,elem.width,elem.height)}};
      }
      else
      {
      	alert("Could not get html5 2d context, your browser doesn't support it! Try firefox or chrome");
      }
    }
    else
    {
      alert("The getContext function was missing, your browser doesn't support it! Try firefox or chrome"); 
    }
  }
  else
  {
    alert("Could not get element 'MainCanvas'");	
  }

  return false;
}

function GetMousePos(canvas, evt)
{
	var rect = g_sourcePanel.elem.getBoundingClientRect();
	var pos =
	[
		evt.clientX - rect.left,
		evt.clientY - rect.top
	];
	return pos;
}

function AddClick(mousePos, drag)
{
	g_clicks.push([mousePos, drag, g_brushSize, g_color]);
	RedrawAll(false);
}

function UndoSource(mousePos, drag)
{
	g_clicks.splice(-1,1);
	RedrawAll(false);
}

function ClearSource ()
{
	g_clicks = new Array();
	RedrawAll(true);
}

function ColorSource ()
{
	g_color = !g_color;
	document.getElementById('Color').value="Color: "+ (g_color ? "White" : "Black");
}

function BrushSize ()
{
	if (g_brushSize < 10)
		g_brushSize++;
	else
		g_brushSize = 1;

	document.getElementById('BrushSize').value="Brush Size: "+g_brushSize;
}

function OnMouseMove(evt)
{
	if (!g_mouseDown)
		return;

	var mousePos = GetMousePos(g_sourcePanel.elem, evt);
	AddClick(mousePos, true);
}

function OnMouseDown(evt)
{
	g_mouseDown = true;
	var mousePos = GetMousePos(g_sourcePanel.elem, evt);
	AddClick(mousePos, false);
}

function OnMouseUp(evt)
{
	g_mouseDown = false;
}

window.addEventListener('load', function(){onPageLoaded();}, false);

function ClearImageBuffer(context, width, height)
{
	FillImageBuffer(context,"#000000", width, height);
}

function FillImageBuffer(context, color, width, height)
{
	context.fillStyle   = color;
	context.fillRect(0, 0, width, height);
}

function RedrawSource()
{
	g_sourcePanel.clear();

	g_sourcePanel.context.lineJoin = "round";

	for(var i=0; i < g_clicks.length; ++i) {
		g_sourcePanel.context.lineWidth = g_clicks[i][2];  
		g_sourcePanel.context.beginPath();

		g_sourcePanel.context.strokeStyle=g_clicks[i][3]?'#FFFFFF':'#000000';

		if(g_clicks[i][1] && i > 0) {
			g_sourcePanel.context.moveTo(g_clicks[i-1][0][0], g_clicks[i-1][0][1]);
		}
		else {
			g_sourcePanel.context.moveTo(g_clicks[i][0][0]-1, g_clicks[i][0][1])
		}

		g_sourcePanel.context.lineTo(g_clicks[i][0][0], g_clicks[i][0][1]);
		g_sourcePanel.context.closePath();
		g_sourcePanel.context.stroke();
	}
}

function ResizeCanvases ()
{
	// make sure they are whole numbers
	document.getElementById('SourceWidth').value = Math.floor(document.getElementById('SourceWidth').value);
	document.getElementById('SourceHeight').value = Math.floor(document.getElementById('SourceHeight').value);

	document.getElementById('EncodedHeight').value = Math.floor(document.getElementById('EncodedHeight').value);

	document.getElementById('ResultWidth').value = Math.floor(document.getElementById('ResultWidth').value);
	document.getElementById('ResultHeight').value = Math.floor(document.getElementById('ResultHeight').value);

	// make sure sizes dont go below 1
	if (document.getElementById('SourceWidth').value < 1)
		document.getElementById('SourceWidth').value = 1;
	if (document.getElementById('SourceHeight').value < 1)
		document.getElementById('SourceHeight').value = 1;	

	if (document.getElementById('EncodedHeight').value < 1)
		document.getElementById('EncodedHeight').value = 1;

	if (document.getElementById('ResultWidth').value < 1)
		document.getElementById('ResultWidth').value = 1;
	if (document.getElementById('ResultHeight').value < 1)
		document.getElementById('ResultHeight').value = 1;

	// resize
	g_sourcePanel.elem.width = document.getElementById('SourceWidth').value;
	g_sourcePanel.elem.height = document.getElementById('SourceHeight').value;

	g_encodedPanel.elem.height = document.getElementById('EncodedHeight').value;
	g_encoded2Panel.elem.height = document.getElementById('EncodedHeight').value;

	g_resultPanel.elem.width = document.getElementById('ResultWidth').value;
	g_resultPanel.elem.height = document.getElementById('ResultHeight').value;	

	RedrawAll(true);
}

function AddEntry (bucket, distSq, isWhite)
{
	bucket.push({"distSq":distSq,"isWhite":isWhite});
	return bucket;
}

function SortBuckets(a,b) {
	return a.distSq - b.distSq;
}

function RedrawEncoded ()
{
	// get access to the encoded and source image sizes
	var encodedWidth = g_encodedPanel.elem.width;
	var encodedHeight = g_encodedPanel.elem.height;
	var encodedData = g_encodedPanel.context.getImageData(0,0,encodedWidth,encodedHeight);

	var encoded2Width = g_encoded2Panel.elem.width;
	var encoded2Height = g_encoded2Panel.elem.height;
	var encoded2Data = g_encoded2Panel.context.getImageData(0,0,encoded2Width,encoded2Height);

	var sourceWidth = g_sourcePanel.elem.width;
	var sourceHeight = g_sourcePanel.elem.height;
	var sourceData = g_sourcePanel.context.getImageData(0,0,sourceWidth,sourceHeight);

	// allocate space for our encoded data buckets
	var encodedBuckets = new Array(encodedHeight);
	for (var y = 0; y < encodedHeight; ++y)
		encodedBuckets[y] = new Array();

	// calculate the maximum distance
	var hypotneuse = Math.sqrt((sourceWidth/2)*(sourceWidth/2)+(sourceHeight/2)*(sourceHeight/2));

	// loop through the source data
	for (var y = 0; y < sourceHeight; ++y)
	{
		for (var x = 0; x < sourceWidth; ++x)
		{
			var isWhite = (sourceData.data[(y*sourceWidth+x)*4] > 0);

			var angle = Math.atan2(y-sourceHeight/2,x-sourceWidth/2);
			if (angle < 0)
				angle += Math.PI * 2;
			angle /= Math.PI*2;
			angle *= encodedHeight;
			angle = Math.floor(angle);

			var normDistX = (x - (sourceWidth/2))/hypotneuse;
			var normDistY = (y - (sourceHeight/2))/hypotneuse;	
			var distSq = normDistX*normDistX + normDistY*normDistY;

			encodedBuckets[angle] = AddEntry(encodedBuckets[angle], distSq, isWhite);
		}
	}

	// convert the encoded buckets to pixels (clear out pixels at same time, and remove clearing from above)
	for (var y = 0; y < encodedHeight; ++y)
	{
		// make sure there's a black entry at 0 and 1
		encodedBuckets[y].splice(0,0,{"distSq":0,"isWhite":false});
		encodedBuckets[y].push({"distSq":1,"isWhite":false});		

		// sort the entries by distance
		encodedBuckets[y].sort(SortBuckets);		

		// make a table of the boundary changes for samples
		var boundaries = new Array();
		var lastIsWhite = true;
		for (var index = 0; index < encodedBuckets[y].length; index++)
		{
			if (index == 0 || lastIsWhite != encodedBuckets[y][index].isWhite)
			{
				lastIsWhite = encodedBuckets[y][index].isWhite;
				boundaries.push(encodedBuckets[y][index].distSq);
			}
		}

		// encode distances for angle!
		var R = boundaries.length > 1 ? Math.min(Math.floor(boundaries[1]*255),255) : 255;
		var G = boundaries.length > 2 ? Math.min(Math.floor(boundaries[2]*255),255) : 255;
		var B = boundaries.length > 3 ? Math.min(Math.floor(boundaries[3]*255),255) : 255;
		var A = boundaries.length > 4 ? Math.min(Math.floor(boundaries[4]*255),255) : 255;

		// apply color
		for (var x = 0; x < encodedWidth; ++x)
		{
			encodedData.data[(y*encodedWidth+x)*4+0] = R;
			encodedData.data[(y*encodedWidth+x)*4+1] = G;
			encodedData.data[(y*encodedWidth+x)*4+2] = B;
			encodedData.data[(y*encodedWidth+x)*4+3] = A;
		}

		for (var x = 0; x < encoded2Width; ++x)
		{
			encoded2Data.data[(y*encoded2Width+x)*4+0] = R;
			encoded2Data.data[(y*encoded2Width+x)*4+1] = G;
			encoded2Data.data[(y*encoded2Width+x)*4+2] = B;
			encoded2Data.data[(y*encoded2Width+x)*4+3] = A;
		}		
	}

	// copy the pixels in
	g_encodedPanel.context.putImageData(encodedData,0,0);
	g_encoded2Panel.context.putImageData(encoded2Data,0,0);
}

function GetEncodedPixelChannel (encodedData, encodedWidth, encodedHeight, normAngle, channel)
{
	// do simple texture lookup if bilinear filtering isn't on
	if (!g_bilinearFilter)
		return encodedData.data[(encodedWidth*Math.floor(normAngle))*4+channel] / 255;

	// only doing vertical axis filtering for now.  will need horizontal later
	// for animations
	var v1 = Math.floor(normAngle);
	var v2 = Math.min(v1 + 1, encodedHeight-1);
	var fract = normAngle % 1;

	var ret =
		encodedData.data[(encodedWidth*v1)*4+channel] * (1-fract) +
		encodedData.data[(encodedWidth*v2)*4+channel] * fract;

	return ret / 255;
}

function GetEncodedPixel (encodedData, encodedWidth, encodedHeight, normAngle)
{
	var encodedDistSq1 = GetEncodedPixelChannel(encodedData, encodedWidth, encodedHeight, normAngle, 0);
	var encodedDistSq2 = GetEncodedPixelChannel(encodedData, encodedWidth, encodedHeight, normAngle, 1);
	var encodedDistSq3 = GetEncodedPixelChannel(encodedData, encodedWidth, encodedHeight, normAngle, 2);
	var encodedDistSq4 = GetEncodedPixelChannel(encodedData, encodedWidth, encodedHeight, normAngle, 3);

	return [encodedDistSq1,encodedDistSq2,encodedDistSq3,encodedDistSq4];
}

function SmoothStep (x)
{
	// assumes x is between 0 and 1 already
	return 3*x*x - 2*x*x*x;
}

function CalcFillValue(distSq, distSqMin, distSqMax)
{
	// Do anti aliasing if we should
	if (g_AAmount > 0)
	{
		var dist = Math.sqrt(distSq);
		var distMin = Math.sqrt(distSqMin);
		var distMax = Math.sqrt(distSqMax);

		if (dist - distMin < g_AAmount)
		{
			return SmoothStep((dist-distMin)/g_AAmount);
		}
		else if (distMax - dist < g_AAmount)
		{
			return SmoothStep((distMax-dist)/g_AAmount);
		}
	}

	// if no anti aliasing, or we aren't near an edge, return the full value
	return 1;
}

function RedrawResult ()
{
	// clear the panel
	g_resultPanel.clear();

	// get the encoded image data
	var encodedWidth = g_encodedPanel.elem.width;
	var encodedHeight = g_encodedPanel.elem.height;
	var encodedData = g_encodedPanel.context.getImageData(0,0,encodedWidth,encodedHeight);

	// make image data for the result data
	var resultWidth = g_resultPanel.elem.width;
	var resultHeight = g_resultPanel.elem.height;
	var resultData = g_resultPanel.context.createImageData(resultWidth,resultHeight);

	// calculate the maximum distance
	var hypotneuse = Math.sqrt((resultWidth/2)*(resultWidth/2)+(resultHeight/2)*(resultHeight/2));

	// make the result
	for (y = 0; y < resultHeight; ++y) {
		for (x = 0; x < resultWidth; ++x) {

			// calculate the x,y distance of this pixel from the center of the image, in -1,+1 range
			var normDistX = (x - (resultWidth/2))/hypotneuse;
			var normDistY = (y - (resultHeight/2))/hypotneuse;

			// calculate the positive angle in radians, then into percentage where 0 to 1 equals 0 to 2pi
			// then take that percentage and map it to which pixel row should be read from the encoded image
			var normAngle = Math.atan2(normDistY,normDistX);
			if (normAngle < 0)
				normAngle += Math.PI * 2;
			normAngle /= Math.PI*2;
			normAngle *= encodedHeight;

			// read the squared distance for that angle from our encoded image, only first frame for now
			// and make it into the 0 to 1 range
			var encodedDistSq = GetEncodedPixel(encodedData, encodedWidth, encodedHeight, normAngle);

			// calculate squared distance
			var distSq = normDistX*normDistX + normDistY*normDistY;

			// figure out whether we are inside the shape or not
			var fillValue = 0;
			if (distSq < encodedDistSq[0])
			{
				fillValue = 0;
			}
			else if (distSq < encodedDistSq[1])
			{
				fillValue = CalcFillValue(distSq, encodedDistSq[0], encodedDistSq[1]);
			}
			else if (distSq < encodedDistSq[2])
			{
				fillValue = 0;
			}
			else if (distSq < encodedDistSq[3])
			{
				fillValue = CalcFillValue(distSq, encodedDistSq[2], encodedDistSq[3]);
			}
			else
			{
				fillValue = 0;
			}

			// write to the pixel: R,G,B,A
			resultData.data[((resultWidth*y)+x)*4+0] = fillValue*255;
			resultData.data[((resultWidth*y)+x)*4+1] = fillValue*255;
			resultData.data[((resultWidth*y)+x)*4+2] = fillValue*255;			
			resultData.data[((resultWidth*y)+x)*4+3] = 255;
		}
	}

    // draw the result
	g_resultPanel.context.putImageData(resultData,0,0);
}

function BytesString (bytes)
{
	if(bytes < 0)
		return "0 bytes";
	else if (bytes < 1)
		return "" + (bytes*8) + " bits";
	else if (bytes < 1024)
		return "" + bytes + " bytes";
	else if (bytes < 1024*1024)
		return "" + (bytes / 1024) + " KB";
	else
		return "" + (bytes / (1024*1024)) + " MB";
}

function RedrawChecker ()
{
	if (g_redrawTimer <= 0)
		return;

	g_redrawTimer-=100;

	if (g_redrawTimer <= 0)
		RedrawAll(true);
}

function RedrawAll (immediate)
{
	if (!immediate)
	{
		RedrawSource();
		g_redrawTimer = 500;
		return;
	}

	g_redrawTimer = 0;

	g_AAmount = document.getElementById('AADist').value / g_resultPanel.elem.width;
	g_bilinearFilter = document.getElementById('BilinearFilter').checked;

	RedrawSource();
	RedrawEncoded();
	RedrawResult();

	var sourceWidth = g_sourcePanel.elem.width;
	var sourceHeight = g_sourcePanel.elem.height;
	var sourcePixels = sourceWidth * sourceHeight;
	document.getElementById('SourceSize').innerHTML="<br>"+sourceWidth+"x"+sourceHeight+"="+sourcePixels+" pixels<br>"+
		"1 bit per pixel="+BytesString(sourcePixels/8)+"<br>"+
		"1 byte per pixel="+BytesString(sourcePixels)+"<br>"+
		"4 bytes per pixel="+BytesString(sourcePixels*4);

	var encodedWidth = g_encodedPanel.elem.width;
	var encodedHeight = g_encodedPanel.elem.height;
	document.getElementById('EncodedSize').innerHTML="<br>"+encodedHeight+" pixels<br>"+
		"4 bytes per pixel="+BytesString(encodedHeight*4)+"<br>";

	var resultWidth = g_resultPanel.elem.width;
	var resultHeight = g_resultPanel.elem.height;
	var resultPixels = resultWidth * resultHeight;
	document.getElementById('ResultSize').innerHTML="<br>"+resultWidth+"x"+resultHeight+"="+resultPixels+" pixels<br>"+
		"1 bit per pixel="+BytesString(resultPixels/8)+"<br>"+
		"1 byte per pixel="+BytesString(resultPixels)+"<br>"+
		"4 bytes per pixel="+BytesString(resultPixels*4);		
}

</script>
</head>
<body>

<h1>RotShape Creator</h1>

<div class="panel">
<canvas class="html5" id="Source" width="256" height="256">Your browser doesn't seem to support the necesary html5 features ):</canvas>
<br>
Source:<input type="text" id="SourceWidth" value="256" style="width:4em" onChange="ResizeCanvases()"/>x<input type="text" id="SourceHeight" value="256" style="width:4em" onChange="ResizeCanvases()"/>
<br>
<input type=button id="BrushSize" value="Brush Size: 5" onClick="BrushSize()"/>
<input type=button id="Color" value="Color: White" onClick="ColorSource()"/>
<input type=button value="Undo" onClick="UndoSource()"/>
<input type=button value="Clear" onClick="ClearSource()"/>
<div id="SourceSize"></div>
</div>

<div class="panel">
<canvas class="html5" id="Result" width="256" height="256">Your browser doesn't seem to support the necesary html5 features ):</canvas>
<br/>
Result:<input type="text" id="ResultWidth" value="256" style="width:4em" onChange="ResizeCanvases()"/>x<input type="text" id="ResultHeight" value="256" style="width:4em" onChange="ResizeCanvases()"/><br>
Bilinear Filter Encoded Data: <input type=checkbox id="BilinearFilter" onChange="RedrawAll(true);"/><br>
AA Distance: <input type="text" id="AADist" value="5" style="width:4em" onChange="RedrawAll(true);"/> (Smoothsteps this many pixels.  0 to turn off AA)
<div id="ResultSize"></div>
</div>

<div class="panel">
actual:
<canvas class="html5" id="Encoded" width="1" height="256">Your browser doesn't seem to support the necesary html5 features ):</canvas>
widened:
<canvas class="html5" id="Encoded2" width="100" height="256">Your browser doesn't seem to support the necesary html5 features ):</canvas>
<br/>
Encoded:<input type="text" id="EncodedHeight" value="256" style="width:4em" onChange="ResizeCanvases()"/>
<div id="EncodedSize"></div>
</div>

</body>
</html>