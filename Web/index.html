<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>RotShape Creator</title>
<style type="text/css">
body { background-color:grey;}
canvas.html5 {border:1px solid white;}
div.panel {float:left; width:33%;}
</style>
<script>

var g_sourcePanel;
var g_encodedPanel;
var g_resultPanel;
var g_mouseDown = false;
var g_brushSize = 5;

var g_AAmount = 0.01;

var g_color = 1;

var g_clicks = new Array();

var g_redrawTimer = 0;

function onPageLoaded()
{
	g_sourcePanel = setupCanvas('Source');
	g_encodedPanel = setupCanvas('Encoded');
	g_resultPanel = setupCanvas('Result');

	g_sourcePanel.elem.addEventListener('mousemove', function(evt) {OnMouseMove(evt);RedrawAll(false);}, false);
	g_sourcePanel.elem.addEventListener('mousedown', function(evt) {OnMouseDown(evt);RedrawAll(false);}, false);
	g_sourcePanel.elem.addEventListener('mouseup', function(evt) {OnMouseUp(evt);RedrawAll(false);}, false);
	RedrawAll(true);

	setInterval(function(){RedrawChecker();}, 250);
}

function setupCanvas(name)
{
  // Get a reference to the element.
  var elem = document.getElementById(name);

  // Always check for properties and methods, to make sure your code doesn't break 
  // in other browsers.
  if (elem)
  {
    if(elem.getContext)
    {
      // Get the 2d context.
      // Remember: you can only initialize one context per element.
      var context = elem.getContext('2d');

      if (context)
      {
      	return {"elem":elem, "context":context, "clear":function(){ClearImageBuffer(context,elem.width,elem.height)}, "fill":function(color){FillImageBuffer(context, color,elem.width,elem.height)}};
      }
      else
      {
      	alert("Could not get html5 2d context, your browser doesn't support it! Try firefox or chrome");
      }
    }
    else
    {
      alert("The getContext function was missing, your browser doesn't support it! Try firefox or chrome"); 
    }
  }
  else
  {
    alert("Could not get element 'MainCanvas'");	
  }

  return false;
}

function GetMousePos(canvas, evt)
{
	var rect = g_sourcePanel.elem.getBoundingClientRect();
	var pos =
	[
		evt.clientX - rect.left,
		evt.clientY - rect.top
	];
	return pos;
}

function AddClick(mousePos, drag)
{
	g_clicks.push([mousePos, drag, g_brushSize, g_color]);
	RedrawAll(false);
}

function UndoSource(mousePos, drag)
{
	g_clicks.splice(-1,1);
	RedrawAll(false);
}

function ClearSource ()
{
	g_clicks = new Array();
	RedrawAll(true);
}

function ColorSource ()
{
	g_color = !g_color;
	document.getElementById('Color').value="Color: "+ (g_color ? "White" : "Black");
}

function BrushSize ()
{
	if (g_brushSize < 10)
		g_brushSize++;
	else
		g_brushSize = 1;

	document.getElementById('BrushSize').value="Brush Size: "+g_brushSize;
}

function OnMouseMove(evt)
{
	if (!g_mouseDown)
		return;

	var mousePos = GetMousePos(g_sourcePanel.elem, evt);
	AddClick(mousePos, true);
}

function OnMouseDown(evt)
{
	g_mouseDown = true;
	var mousePos = GetMousePos(g_sourcePanel.elem, evt);
	AddClick(mousePos, false);
}

function OnMouseUp(evt)
{
	g_mouseDown = false;
}

window.addEventListener('load', function(){onPageLoaded();}, false);

function ClearImageBuffer(context, width, height)
{
	FillImageBuffer(context,"#000000", width, height);
}

function FillImageBuffer(context, color, width, height)
{
	context.fillStyle   = color;
	context.fillRect(0, 0, width, height);
}

function RedrawSource()
{
	g_sourcePanel.clear();

	g_sourcePanel.context.lineJoin = "round";

	for(var i=0; i < g_clicks.length; ++i) {
		g_sourcePanel.context.lineWidth = g_clicks[i][2];  
		g_sourcePanel.context.beginPath();

		g_sourcePanel.context.strokeStyle=g_clicks[i][3]?'#FFFFFF':'#000000';

		if(g_clicks[i][1] && i > 0) {
			g_sourcePanel.context.moveTo(g_clicks[i-1][0][0], g_clicks[i-1][0][1]);
		}
		else {
			g_sourcePanel.context.moveTo(g_clicks[i][0][0], g_clicks[i][0][1])
		}

		g_sourcePanel.context.lineTo(g_clicks[i][0][0], g_clicks[i][0][1]);
		g_sourcePanel.context.closePath();
		g_sourcePanel.context.stroke();
	}
}

function ResizeCanvases ()
{
	// make sure they are whole numbers
	document.getElementById('SourceWidth').value = Math.floor(document.getElementById('SourceWidth').value);
	document.getElementById('SourceHeight').value = Math.floor(document.getElementById('SourceHeight').value);

	document.getElementById('EncodedHeight').value = Math.floor(document.getElementById('EncodedHeight').value);

	document.getElementById('ResultWidth').value = Math.floor(document.getElementById('ResultWidth').value);
	document.getElementById('ResultHeight').value = Math.floor(document.getElementById('ResultHeight').value);

	// make sure sizes dont go below 1
	if (document.getElementById('SourceWidth').value < 1)
		document.getElementById('SourceWidth').value = 1;
	if (document.getElementById('SourceHeight').value < 1)
		document.getElementById('SourceHeight').value = 1;	

	if (document.getElementById('EncodedHeight').value < 1)
		document.getElementById('EncodedHeight').value = 1;

	if (document.getElementById('ResultWidth').value < 1)
		document.getElementById('ResultWidth').value = 1;
	if (document.getElementById('ResultHeight').value < 1)
		document.getElementById('ResultHeight').value = 1;

	// resize
	g_sourcePanel.elem.width = document.getElementById('SourceWidth').value;
	g_sourcePanel.elem.height = document.getElementById('SourceHeight').value;

	g_encodedPanel.elem.height = document.getElementById('EncodedHeight').value;

	g_resultPanel.elem.width = document.getElementById('ResultWidth').value;
	g_resultPanel.elem.height = document.getElementById('ResultHeight').value;	

	RedrawAll(true);
}

function RedrawEncoded ()
{
	g_encodedPanel.fill("#A0B0F0");


	var encodedWidth = g_encodedPanel.elem.width;
	var encodedHeight = g_encodedPanel.elem.height;
	var encodedData = g_encodedPanel.context.getImageData(0,0,encodedWidth,encodedHeight);

	for (var y = 0; y < encodedHeight; ++y)
	{
		var offset = Math.sin(y/Math.PI)*5;
		var r = 30+offset;
		var g = 50+offset;
		var b = 110+offset;
		var a = 150+offset;
		for (var x = 0; x < encodedWidth; ++x)
		{
			encodedData.data[((y*encodedWidth)+x)*4+0]=r;
			encodedData.data[((y*encodedWidth)+x)*4+1]=g;
			encodedData.data[((y*encodedWidth)+x)*4+2]=b;
			encodedData.data[((y*encodedWidth)+x)*4+3]=a;
		}
	}


	g_encodedPanel.context.putImageData(encodedData,0,0);
}

function GetEncodedPixelChannel (encodedData, encodedWidth, encodedHeight, normAngle, channel)
{
	// only doing vertical axis filtering for now.  will need horizontal later
	// for animations
	var v1 = Math.floor(normAngle);
	var v2 = Math.min(v1 + 1, encodedHeight-1);
	var fract = normAngle % 1;

	var ret =
		encodedData.data[(encodedWidth*v1)*4+channel] * (1-fract) +
		encodedData.data[(encodedWidth*v2)*4+channel] * fract;

	return ret / 255;
}

function GetEncodedPixel (encodedData, encodedWidth, encodedHeight, normAngle)
{
	var encodedDistSq1 = GetEncodedPixelChannel(encodedData, encodedWidth, encodedHeight, normAngle, 0);
	var encodedDistSq2 = GetEncodedPixelChannel(encodedData, encodedWidth, encodedHeight, normAngle, 1);
	var encodedDistSq3 = GetEncodedPixelChannel(encodedData, encodedWidth, encodedHeight, normAngle, 2);
	var encodedDistSq4 = GetEncodedPixelChannel(encodedData, encodedWidth, encodedHeight, normAngle, 3);

	return [encodedDistSq1,encodedDistSq2,encodedDistSq3,encodedDistSq4];
}

function SmoothStep (x)
{
	// assumes x is between 0 and 1 already
	return 3*x*x - 2*x*x*x;
}

function CalcFillValue(distSq, distSqMin, distSqMax)
{
	// Do anti aliasing if we should
	if (g_AAmount > 0)
	{
		var dist = Math.sqrt(distSq);
		var distMin = Math.sqrt(distSqMin);
		var distMax = Math.sqrt(distSqMax);

		if (dist - distMin < g_AAmount)
		{
			return SmoothStep((dist-distMin)/g_AAmount);
		}
		else if (distMax - dist < g_AAmount)
		{
			return SmoothStep((distMax-dist)/g_AAmount);
		}
	}

	// if no anti aliasing, or we aren't near an edge, return the full value
	return 1;
}

function RedrawResult ()
{
	// clear the panel
	g_resultPanel.clear();

	// get the encoded image data
	var encodedWidth = g_encodedPanel.elem.width;
	var encodedHeight = g_encodedPanel.elem.height;
	var encodedData = g_encodedPanel.context.getImageData(0,0,encodedWidth,encodedHeight);

	// make image data for the result data
	var resultWidth = g_resultPanel.elem.width;
	var resultHeight = g_resultPanel.elem.height;
	var resultData = g_resultPanel.context.createImageData(resultWidth,resultHeight);

	// make the result
	for (y = 0; y < resultHeight; ++y) {
		for (x = 0; x < resultWidth; ++x) {

			// calculate the x,y distance of this pixel from the center of the image, in -1,+1 range
			var normDistX = (x - (resultWidth/2))/(resultWidth/2);
			var normDistY = (y - (resultHeight/2))/(resultHeight/2);

			// calculate the positive angle in radians, then into percentage where 0 to 1 equals 0 to 2pi
			// then take that percentage and map it to which pixel row should be read from the encoded image
			var normAngle = Math.atan2(normDistY,normDistX);
			if (normAngle < 0)
				normAngle += Math.PI * 2;
			normAngle /= Math.PI*2;
			normAngle *= encodedHeight;

			// read the squared distance for that angle from our encoded image, only first frame for now
			// and make it into the 0 to 1 range
			var encodedDistSq = GetEncodedPixel(encodedData, encodedWidth, encodedHeight, normAngle);

			// calculate squared distance
			var distSq = normDistX*normDistX + normDistY*normDistY;

			// figure out whether we are inside the shape or not
			var fillValue = 0;
			if (distSq < encodedDistSq[0])
			{
				fillValue = 0;
			}
			else if (distSq < encodedDistSq[1])
			{
				fillValue = CalcFillValue(distSq, encodedDistSq[0], encodedDistSq[1]);
			}
			else if (distSq < encodedDistSq[2])
			{
				fillValue = 0;
			}
			else if (distSq < encodedDistSq[3])
			{
				fillValue = CalcFillValue(distSq, encodedDistSq[2], encodedDistSq[3]);
			}
			else
			{
				fillValue = 0;
			}

			// write to the pixel: R,G,B,A
			resultData.data[((resultWidth*y)+x)*4+0] = fillValue*255;
			resultData.data[((resultWidth*y)+x)*4+1] = fillValue*255;
			resultData.data[((resultWidth*y)+x)*4+2] = fillValue*255;			
			resultData.data[((resultWidth*y)+x)*4+3] = 255;
		}
	}

    // draw the result
	g_resultPanel.context.putImageData(resultData,0,0);
}

function BytesString (bytes)
{
	if(bytes < 0)
		return "0 bytes";
	else if (bytes < 1)
		return "" + (bytes*8) + " bits";
	else if (bytes < 1024)
		return "" + bytes + " bytes";
	else if (bytes < 1024*1024)
		return "" + (bytes / 1024) + " KB";
	else
		return "" + (bytes / (1024*1024)) + " MB";
}

function RedrawChecker ()
{
	if (g_redrawTimer <= 0)
		return;

	g_redrawTimer-=250;

	if (g_redrawTimer <= 0)
		RedrawAll(true);
}

function RedrawAll (immediate)
{
	if (!immediate)
	{
		RedrawSource();
		g_redrawTimer = 500;
		return;
	}

	g_redrawTimer = 0;

	g_AAmount = document.getElementById('AADist').value / g_resultPanel.elem.width;

	RedrawEncoded();
	RedrawSource();
	RedrawResult();

	var sourceWidth = g_sourcePanel.elem.width;
	var sourceHeight = g_sourcePanel.elem.height;
	var sourcePixels = sourceWidth * sourceHeight;
	document.getElementById('SourceSize').innerHTML="<br>"+sourceWidth+"x"+sourceHeight+"="+sourcePixels+" pixels<br>"+
		"1 bit per pixel="+BytesString(sourcePixels/8)+"<br>"+
		"1 byte per pixel="+BytesString(sourcePixels)+"<br>"+
		"4 bytes per pixel="+BytesString(sourcePixels*4);

	var encodedWidth = g_encodedPanel.elem.width;
	var encodedHeight = g_encodedPanel.elem.height;
	document.getElementById('EncodedSize').innerHTML="<br>"+encodedHeight+" pixels per frame<br>"+
		"4 bytes per pixel="+BytesString(encodedHeight*4)+" per frame<br>"+
		"x " + encodedWidth + " frames = " + BytesString(encodedHeight*4*encodedWidth);	

	var resultWidth = g_resultPanel.elem.width;
	var resultHeight = g_resultPanel.elem.height;
	var resultPixels = resultWidth * resultHeight;
	document.getElementById('ResultSize').innerHTML="<br>"+resultWidth+"x"+resultHeight+"="+resultPixels+" pixels<br>"+
		"1 bit per pixel="+BytesString(resultPixels/8)+"<br>"+
		"1 byte per pixel="+BytesString(resultPixels)+"<br>"+
		"4 bytes per pixel="+BytesString(resultPixels*4);		
}

</script>
</head>
<body>

<h1>RotShape Creator</h1>

<div class="panel">
<canvas class="html5" id="Source" width="256" height="256">Your browser doesn't seem to support the necesary html5 features ):</canvas>
<br>
Source:<input type="text" id="SourceWidth" value="256" style="width:4em" onChange="ResizeCanvases()"/>x<input type="text" id="SourceHeight" value="256" style="width:4em" onChange="ResizeCanvases()"/>
<br>
<input type=button id="BrushSize" value="Brush Size: 5" onClick="BrushSize()"/>
<input type=button id="Color" value="Color: White" onClick="ColorSource()"/>
<input type=button value="Undo" onClick="UndoSource()"/>
<input type=button value="Clear" onClick="ClearSource()"/>
<div id="SourceSize"></div>
</div>

<div class="panel">
<canvas class="html5" id="Encoded" width="1" height="256">Your browser doesn't seem to support the necesary html5 features ):</canvas>
<br/>
Encoded:<input type="text" id="EncodedHeight" value="256" style="width:4em" onChange="ResizeCanvases()"/>
<div id="EncodedSize"></div>
</div>

<div class="panel">
<canvas class="html5" id="Result" width="512" height="512">Your browser doesn't seem to support the necesary html5 features ):</canvas>
<br/>
Result:<input type="text" id="ResultWidth" value="512" style="width:4em" onChange="ResizeCanvases()"/>x<input type="text" id="ResultHeight" value="512" style="width:4em" onChange="ResizeCanvases()"/><br>
AA Distance: <input type="text" id="AADist" value="5" style="width:4em" onChange="RedrawAll(true);"/> (Smoothsteps this many pixels.  0 to turn off AA)
<div id="ResultSize"></div>

</div>

</body>
</html>